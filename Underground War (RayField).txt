--[[

Rewritten UI: RayField (https://sirius.menu/rayfield)
Improved Notifications System
]]

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Improved notification functions using RayField's notification system
local function notify(title, content, duration, image)
	title = title or "Underground War"
	content = content or "Notification"
	duration = duration or 5
	image = image or "bell" -- Default icon
	
	Rayfield:Notify({
		Title = title,
		Content = content,
		Duration = duration,
		Image = image,
		Actions = {
			Ignore = {
				Name = "Dismiss",
				Callback = function()
					-- Notification dismissed
				end
			},
		},
	})
end

local function notifySuccess(title, content, duration)
	title = title or "Success"
	content = content or "Operation completed successfully"
	duration = duration or 4
	
	Rayfield:Notify({
		Title = "âœ… " .. title,
		Content = content,
		Duration = duration,
		Image = "bell",
		Actions = {
			Ignore = {
				Name = "Great!",
				Callback = function()
					-- Success acknowledged
				end
			},
		},
	})
end

local function notifyWarning(title, content, duration)
	title = title or "Warning"
	content = content or "Please check your settings"
	duration = duration or 6
	
	Rayfield:Notify({
		Title = "âš ï¸ " .. title,
		Content = content,
		Duration = duration,
		Image = "bell",
		Actions = {
			Ignore = {
				Name = "Understood",
				Callback = function()
					-- Warning acknowledged
				end
			},
		},
	})
end

local function notifyError(title, content, duration)
	title = title or "Error"
	content = content or "Something went wrong"
	duration = duration or 7
	
	Rayfield:Notify({
		Title = "âŒ " .. title,
		Content = content,
		Duration = duration,
		Image = "bell",
		Actions = {
			Ignore = {
				Name = "Retry",
				Callback = function()
					-- Error acknowledged
				end
			},
		},
	})
end

local function notifyWithActions(title, content, actions, duration, image)
	title = title or "Action Required"
	content = content or "Please choose an action"
	duration = duration or 10
	image = image or "bell"
	
	local notifActions = {}
	for actionName, callback in pairs(actions) do
		notifActions[actionName] = {
			Name = actionName,
			Callback = callback
		}
	end
	
	Rayfield:Notify({
		Title = title,
		Content = content,
		Duration = duration,
		Image = image,
		Actions = notifActions,
	})
end

local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local MarketplaceService = game:GetService("MarketplaceService")
local TweenService = game:GetService("TweenService")

local autoT = false -- auto Tool
local loop = true
local retry = true -- retry for tp kill
local autoU = true -- auto update Target
_G.name = "sword" -- Tool name
Mode = "enemy"
local reach = 10
local auto = true -- auto detect if there's a team

local G = loadstring(game:HttpGet("https://raw.githubusercontent.com/Bwhw827g29wh/47448/refs/heads/main/GetPlayers.lua"))()
local Target = G:getPlayers("enemies")

local Whitelist = { ["mokiku0929"] = true, ["mokiku0939"] = true }
local Blacklist = {}

local function addToWhitelist(playerName)
	if not Whitelist[playerName] then
		Whitelist[playerName] = true
		notifySuccess("Whitelist Updated", playerName .. " has been added to the whitelist successfully", 4)
	else
		notifyWarning("Already Whitelisted", playerName .. " is already protected in the whitelist", 4)
	end
end

local function removeFromWhitelist(playerName)
	if Whitelist[playerName] then
		Whitelist[playerName] = nil
		notify("Whitelist Updated", playerName .. " has been removed from the whitelist", 4)
	else
		notifyWarning("Not Found", playerName .. " was not found in the whitelist", 4)
	end
end

local function addToBlacklist(playerName)
	if not Blacklist[playerName] then
		Blacklist[playerName] = true
		notify("Blacklist Updated", playerName .. " has been added to the blacklist", 4)
	else
		notifyWarning("Already Blacklisted", playerName .. " is already in the blacklist", 4)
	end
end

local function removeFromBlacklist(playerName)
	if Blacklist[playerName] then
		Blacklist[playerName] = nil
		notify("Blacklist Updated", playerName .. " has been removed from the blacklist", 4)
	else
		notifyWarning("Not Found", playerName .. " was not found in the blacklist", 4)
	end
end

local function isWhitelisted(playerName)
	return (Whitelist[playerName] ~= nil or Whitelist[playerName.Name] ~= nil)
end

local function isBlacklisted(playerName)
	return Blacklist[playerName] ~= nil
end

local function findTool(searchString)
	local lowerSearchString = searchString:lower()
	for _, tool in pairs(plr.Backpack:GetChildren()) do
		if tool:IsA("Tool") and tool.Name:lower():match(lowerSearchString) then
			return tool
		end
	end
	for _, tool in pairs(plr.Character:GetChildren()) do
		if tool:IsA("Tool") and tool.Name:lower():match(lowerSearchString) then
			return tool
		end
	end
	return nil
end

local AntiCheat
local Checks
local Areas
local TeleportToArea
local GetEnemyTeam
local alrTP = false
if game.PlaceId == 9791603388 then
	AntiCheat = workspace.AntiCheat
	Checks = {
		Blue = AntiCheat.Blue,
		Red = AntiCheat.Red
	}
	Areas = {
		Red = CFrame.new(0, 14, 100),
		Blue = CFrame.new(0, 14, -100),
		Underground = CFrame.new(0, 0, 0),
		Safespot = CFrame.new(0, -5, 0)
	}
	TeleportToArea = function()
		local rootPart = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
		local playerTeam = plr.Team
		if rootPart then
			if tostring(playerTeam) == "Red" then
				rootPart.CFrame = Checks["Red"].CFrame
				wait(0.25)
				rootPart.CFrame = Checks["Blue"].CFrame
				wait(0.25)
			elseif tostring(playerTeam) == "Blue" then
				rootPart.CFrame = Checks["Blue"].CFrame
				wait(0.25)
				rootPart.CFrame = Checks["Red"].CFrame
				wait(0.25)
			end
			alrTP = true
			notifySuccess("Anti-Cheat Bypass", "Successfully bypassed area restrictions", 3)
		else
			notifyError("Teleport Failed", "Character RootPart not found", 5)
		end
	end
end

local function getTool()
	local h = findTool(_G.name)
	return h
end

local auraL = true
local auraRange = 30
local function aura(h, ch, r, f, ray)
	if h and h:FindFirstChild("Handle") then
		if type(r) ~= "number" then
			r = auraRange
		elseif f then
			r = 8373763
		end
		local v
		if ch:IsA"Player" then
			v = ch.Character
		elseif ch:IsA"Model" then
			v = ch
		end
		if v ~= plr or Players:GetPlayerFromCharacter(v) ~= plr then
			local humanoid = v:FindFirstChildOfClass("Humanoid")
			local targetRootPart = humanoid and humanoid.RootPart
			if humanoid and humanoid.Health > 0 and not v:FindFirstChildOfClass("ForceField") and plr.Character and plr.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
				if plr:DistanceFromCharacter(targetRootPart.Position) <= r then
					if ray then
						local startPosition = plr.Character.HumanoidRootPart.Position
						local direction = (targetRootPart.Position - startPosition).unit * r
						local raycastResult = workspace:Raycast(startPosition, direction)
						if raycastResult and raycastResult.Instance then
							if raycastResult.Instance:IsDescendantOf(v) then
								if h.Parent ~= plr.Character then
									h.Parent = plr.Character
								end
								h:Activate()
								for _, p in pairs(v:GetChildren()) do
									if p:IsA("BasePart") then
										firetouchinterest(h.Handle, p, 0)
										firetouchinterest(h.Handle, p, 1)
									end
								end
							end
						else
							if h.Parent ~= plr.Character then
								h.Parent = plr.Character
							end
							h:Activate()
							for _, p in pairs(v:GetChildren()) do
								if p:IsA("BasePart") then
									firetouchinterest(h.Handle, p, 0)
									firetouchinterest(h.Handle, p, 1)
								end
							end
						end
					else
						if h.Parent ~= plr.Character then
							h.Parent = plr.Character
						end
						h:Activate()
						for _, p in pairs(v:GetChildren()) do
							if p:IsA("BasePart") then
								firetouchinterest(h.Handle, p, 0)
								firetouchinterest(h.Handle, p, 1)
							end
						end
					end
				end
			end
		end
	end
end

local function tp(t, c)
	if t and plr and plr.Character then
		local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
		if humanoid and humanoid.RootPart then
			if game.PlaceId == 9791603388 and c then
				if not alrTP then
					TeleportToArea()
				else
					-- already did
				end
				humanoid.RootPart.CFrame = t.Character:FindFirstChildWhichIsA("Humanoid").RootPart.CFrame * CFrame.new(-1.6, 0, 1.8)
			else
				humanoid.RootPart.CFrame = t.Character:FindFirstChildWhichIsA("Humanoid").RootPart.CFrame * CFrame.new(-1.6, 0, 1.8)
			end
			return true
		else
			notifyError("Teleport Failed", "Humanoid or RootPart not found in player's character", 5)
		end
	else
		notifyError("Invalid Target", "Target player or character is invalid", 5)
	end
	return false
end

local function tp2(enemies)
	if not enemies or #enemies == 0 then 
		notifyWarning("No Targets", "No enemies found for teleportation", 4)
		return 
	end
	
	notify("Teleport Sequence", "Starting multi-target teleportation...", 3)
	local originalPosition = plr.Character.HumanoidRootPart.Position
	
	for _, enemy in pairs(enemies) do
		if enemy and enemy.Character then
			local humanoid = enemy.Character:FindFirstChildWhichIsA("Humanoid")
			local rootPart = humanoid and humanoid.RootPart
			if rootPart then
				local teleportPosition
				if game.PlaceId == 9791603388 then
					teleportPosition = rootPart.CFrame * CFrame.new(0, -11, 0)
				else
					teleportPosition = rootPart.CFrame * CFrame.new(-1.6, 0, 1.8)
				end
				local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
				local tween = TweenService:Create(plr.Character.HumanoidRootPart, tweenInfo, { CFrame = teleportPosition })
				tween:Play()
				tween.Completed:Wait()
			end
		end
	end
	local returnTween = TweenService:Create(plr.Character.HumanoidRootPart, TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), { CFrame = CFrame.new(originalPosition) })
	returnTween:Play()
	returnTween.Completed:Wait()
	
	notifySuccess("Teleport Complete", "Multi-target teleportation sequence finished", 3)
end

local function KillAura()
	loop = true
	notifySuccess("Kill Aura Started", "Kill Aura is now active in " .. Mode .. " mode", 4)
	
	if Mode == "enemy" then
		repeat
			for _, player in pairs(Players:GetPlayers()) do
				if isWhitelisted(player.Name) then continue end
				pcall(function()
					if player ~= plr and player.Team ~= plr.Team and not isWhitelisted(player) then
						local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
						local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
						if humanoid and rootPart and humanoid.Health > 0 and plr.Character.Humanoid.Health > 0 and player.Character:FindFirstChildOfClass("ForceField") == nil and plr:DistanceFromCharacter(rootPart.Position) <= reach then
							local h
							if not autoT then
								h = getTool()
							elseif autoT and plr.Character:FindFirstChildOfClass("Tool") then
								h = plr.Character:FindFirstChildOfClass("Tool")
							end
							if h then
								if h.Parent ~= plr.Character then
									h.Parent = plr.Character
								end
								tp(player)
								humanoid.PlatformStand = true
								aura(h, player, 10)
								if humanoid.Health <= 0 or plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
									loop = false
									if retry then
										wait(1)
										KillAura()
									end
								end
							else
								notifyWarning("Tool Missing", "No suitable tool found. Please equip a weapon", 4)
							end
						end
					end
				end)
			end
			RunService.Heartbeat:Wait()
		until not loop
	elseif Mode == "others" then
		repeat
			for _, player in pairs(Players:GetPlayers()) do
				if isWhitelisted(player.Name) then continue end
				pcall(function()
					if player ~= plr and not isWhitelisted(player) then
						local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
						local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
						if humanoid and rootPart and humanoid.Health > 0 and plr.Character.Humanoid.Health > 0 and player.Character:FindFirstChildOfClass("ForceField") == nil and plr:DistanceFromCharacter(rootPart.Position) <= reach then
							local h
							if not autoT then
								h = getTool()
							elseif autoT and plr.Character:FindFirstChildOfClass("Tool") then
								h = plr.Character:FindFirstChildOfClass("Tool")
							end
							if h then
								if h.Parent ~= plr.Character then
									h.Parent = plr.Character
								end
								tp(player)
								humanoid.PlatformStand = true
								aura(h, player, 10)
								if humanoid.Health <= 0 or plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
									loop = false
									if retry then
										wait(1)
										KillAura()
									end
								end
							else
								notifyWarning("Tool Missing", "No suitable tool found. Please equip a weapon", 4)
							end
						end
					end
				end)
			end
			RunService.Heartbeat:Wait()
		until not loop
	end
end

function GC(String)
	local clipBoard = setclipboard or toclipboard or set_clipboard or (Clipboard and Clipboard.set)
	if clipBoard then
		clipBoard(String)
		notifySuccess('Clipboard', 'Content copied to clipboard successfully', 3)
	else
		notifyError('Clipboard Error', "Failed to access clipboard functionality", 5)
	end
end

local function modeDetector()
	if auto == true then
		if not game:GetService("Teams"):FindFirstChildOfClass("Team") then
			Mode = "others"
			notify("Mode Detection", "Auto-detected mode: Target Others (No teams found)", 4)
		else
			Mode = "enemy"
			notify("Mode Detection", "Auto-detected mode: Enemy Team Only", 4)
		end
	else
		-- manual
	end
end

-- RayField Window and Tabs
local Window = Rayfield:CreateWindow({
	Name = "Sword Fight Aura V2.2",
	LoadingTitle = "Sword Fight Aura V2.2",
	LoadingSubtitle = "RayField UI - Enhanced Edition",
	ConfigurationSaving = { Enabled = false },
	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false,
	KeySystem = false,
})

local TabMain = Window:CreateTab("ðŸ—¡ï¸ Kill Aura", "swords")

TabMain:CreateButton({
	Name = "ðŸŽ¯ Start TP Kill",
	Callback = function()
		modeDetector()
		loop = true
		retry = true
		KillAura()
	end
})

TabMain:CreateButton({
	Name = "â¹ï¸ Stop TP Kill",
	Callback = function()
		loop = false
		retry = false
		notify("Kill Aura Stopped", "TP Kill has been deactivated", 3)
	end
})

TabMain:CreateButton({
	Name = "ðŸ”§ Show Tool Information",
	Callback = function()
		local foundTool = false
		for i, v in pairs(plr.Character:GetChildren()) do
			if v:IsA"Tool" then
				foundTool = true
				notifyWithActions(
					"Tool Found: " .. v.Name,
					"Would you like to set this as your target tool?",
					{
						["Set as Target"] = function()
							_G.name = tostring(v.Name)
							wait(0.5)
							notifySuccess("Target Tool Updated", "Current target tool: " .. _G.name, 4)
						end,
						["Keep Current"] = function()
							notify("Tool Settings", "Current target tool remains: " .. _G.name, 3)
						end
					},
					15
				)
				break
			end
		end
		if not foundTool then
			notifyWarning("No Tool Equipped", "Please equip a tool first, then try again", 5)
		end
	end
})

TabMain:CreateInput({
	Name = "ðŸ“ Configure Ranges",
	PlaceholderText = "r<number> for reach, a<number> for aura",
	RemoveTextAfterFocusLost = false,
	Callback = function(text)
		if text ~= "" then
			local firstChar = text:sub(1, 1):lower()
			local value = tonumber(text:sub(2, #text))
			if value and value > 0 then
				if firstChar == "r" then
					reach = value
					notifySuccess("Range Updated", "TP Range set to " .. reach .. " studs", 3)
				elseif firstChar == "a" then
					auraRange = value
					notifySuccess("Range Updated", "Auto Sword set to " .. auraRange .. " studs", 3)
				else
					notifyWarning("Invalid Command", "Use 'r' for TP Range or 'a' for Auto Sword (e.g., r15 or a25)", 5)
				end
			else
				notifyError("Invalid Input", "Please enter a valid positive number after r/a", 5)
			end
		end
	end
})

TabMain:CreateToggle({
	Name = "ðŸ¤– Auto Detect Tool",
	CurrentValue = false,
	Callback = function(bool)
		if bool then
			notifyWarning("Auto Tool Enabled", "Make sure to equip your weapon first!", 6)
			notifyWarning("âš ï¸ Warning", "Not recommended if equipped item is not a sword/weapon", 6)
			autoT = true
		else
			autoT = false
			notify("Auto Tool Disabled", "Manual tool selection is now active", 3)
		end
	end
})

TabMain:CreateDropdown({
	Name = "ðŸŽ® Combat Mode",
	Options = {"auto","enemies only","others"},
	CurrentOption = "auto",
	MultipleOptions = false,
	Callback = function(o)
		if o == "enemies only" then
			Mode = "enemy"
			auto = false
			notify("Mode Changed", "Now targeting enemy team members only", 4)
		elseif o == "others" then
			Mode = "others"
			auto = false
			notify("Mode Changed", "Now targeting all other players", 4)
		elseif o == "auto" then
			auto = true
			notify("Mode Changed", "Auto-detection enabled - mode will be determined automatically", 4)
		end
	end
})

-- Welcome notification with enhanced actions
notifyWithActions(
	"ðŸŽ® Underground War Script",
	"Welcome! Have fun!",
	{
		["ðŸ‘ Got it!"] = function()
			notify("Ready to Fight", "Script loaded successfully! Configure your settings and start.", 4)
		end
	},
	15,
	"bell"
)

notifySuccess("Script Loaded", "Universal Sword Fights Script - Special Edition", 5)

local alrL = "enemies"
local function autoU()
	while true do
		if G:getPlayers(alrL) then
			Target = G:getPlayers(alrL)
		end
		RunService.Heartbeat:Wait()
	end
end

local TabSpecial = Window:CreateTab("âš¡ Special Edition", "flame")
TabSpecial:CreateInput({
	Name = "ðŸŽ¯ Target Selection",
	PlaceholderText = "players/me/random/enemies/all/others/team or name",
	RemoveTextAfterFocusLost = false,
	Callback = function(text)
		if text ~= "" then
			alrL = text
			notify("Target Updated", "Now targeting: " .. text, 4)
		end
	end
})

local lop
local lastpos
local db = true

TabSpecial:CreateButton({
	Name = "âš¡ Fast Kill",
	Callback = function()
		if db then
			db = false
			lop = true
			auraL = true
			notify("Fast Kill Started", "Initiating high-speed elimination sequence...", 4)
			
			local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
			if humanoid then
				local lastpos = humanoid.RootPart.CFrame
				alrTP = false
				if #Target > 0 then
					repeat
						for _, v in pairs(Target) do
							if isWhitelisted(v.Name) then continue end
							if v ~= plr and v.Character and not isWhitelisted(v) then
								local targetHumanoid = v.Character:FindFirstChildOfClass("Humanoid")
								local targetRootPart = v.Character:FindFirstChild("HumanoidRootPart")
								if targetHumanoid and targetHumanoid.Health > 0 and humanoid.Health > 0 and not v.Character:FindFirstChildOfClass("ForceField") then
									local h
									if not autoT then
										h = getTool()
									elseif autoT then
										h = plr.Character:FindFirstChildOfClass("Tool")
									end
									if targetHumanoid.Health < 0 and humanoid.Health < 0 and targetHumanoid:GetState() == Enum.HumanoidStateType.Dead then
										lop = false
										db = true
										break
									end
									if h then
										h.Parent = plr.Character
										targetHumanoid.PlatformStand = true
										h:Activate()
										tp(v, true)
										aura(h, v, nil, true)
									end
								end
							end
						end
						RunService.Heartbeat:Wait()
					until not lop
					db = true
					humanoid.RootPart.CFrame = lastpos
					notifySuccess("Fast Kill Complete", "High-speed elimination finished", 4)
				else
					notifyWarning("No Targets", "No valid targets found for Fast Kill", 4)
					db = true
				end
			else
				notifyError("Character Error", "Player character not found", 5)
				db = true
			end
		else
			notifyWarning("Please Wait", "Fast Kill is still processing, please wait...", 3)
			wait(1)
			db = true
		end
	end
})

TabSpecial:CreateButton({
	Name = "â¹ï¸ Stop Fast Kill",
	Callback = function()
		lop = false
		notify("Fast Kill Stopped", "High-speed elimination has been stopped", 3)
	end
})

local Isray = true
local TNPC = false

TabSpecial:CreateToggle({
	Name = "ðŸŽ¯ Ray Casting",
	CurrentValue = true,
	Callback = function(bool)
		Isray = bool
		if bool then
			notifySuccess("Ray Casting", "Enabled - More accurate target detection", 3)
		else
			notify("Ray Casting", "Disabled - Standard targeting mode", 3)
		end
	end
})

TabSpecial:CreateToggle({
	Name = "ðŸ¤– Target NPCs [May Cause Lag]",
	CurrentValue = false,
	Callback = function(bool)
		TNPC = bool
		if bool then
			notifyWarning("NPC Targeting", "Enabled - This may cause performance issues", 5)
		else
			notify("NPC Targeting", "Disabled - Targeting players only", 3)
		end
	end
})

TabSpecial:CreateToggle({
	Name = "ðŸŒŠ Real Aura",
	CurrentValue = false,
	Callback = function(bool)
		if bool then
			auraL = true
			notifySuccess("Real Aura", "Activated - Continuous area damage enabled", 4)
			repeat
				pcall(function()
					local h
					if not autoT then
						h = getTool()
					elseif autoT and plr.Character:FindFirstChildOfClass("Tool") then
						h = plr.Character:FindFirstChildOfClass("Tool")
					end
					if h then
						if not TNPC then
							for i, v in pairs(Target) do
								if isWhitelisted(v) or isWhitelisted(v.Name) then continue end
								aura(h, v, nil, nil, Isray)
							end
						else
							for i, v in pairs(workspace:GetDescendants()) do
								if v:IsA"Model" and v:FindFirstChildOfClass("Humanoid") then
									if isWhitelisted(v) or isWhitelisted(v.Name) then continue end
									aura(h, v, nil, nil, Isray)
								end
							end
						end
					end
				end)
				RunService.Heartbeat:Wait()
			until not auraL
		else
			auraL = false
			notify("Real Aura", "Deactivated - Area damage disabled", 3)
		end
	end
})

local function hindiKanaNiyaMahal(...)
	for sakit, iiyak in pairs({...}) do
		if iiyak and iiyak:IsA("Player") then
			local puso = iiyak.Character and iiyak.Character:FindFirstChildWhichIsA("Humanoid")
			if puso then
				if puso:GetState() == Enum.HumanoidStateType.Dead then
					return true
				end
			end
		end
	end
	return false
end

if game.PlaceId == (9791603388) then
	local undTab = Window:CreateTab("ðŸŽ¯ " .. MarketplaceService:GetProductInfo(9791603388).Name, "crosshair")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RemoteEvent = ReplicatedStorage.Events.Remote.ShotTarget
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local player = Players.LocalPlayer
	local shooting = false
	-- Ultimate Auto Shoot state
	local Camera = workspace.CurrentCamera
	local currentTarget = nil
	local lastTargetStamp = 0
	local hbConn = nil
	local aimSmoother = { last = nil }
	
	local function getAimPartPosition(targetPlayer, partName)
		local ch = targetPlayer and targetPlayer.Character
		if not ch then return nil end
		local part = (partName == "HumanoidRootPart" and ch:FindFirstChild("HumanoidRootPart"))
			or (partName == "UpperTorso" and ch:FindFirstChild("UpperTorso"))
			or ch:FindFirstChild("Head")
		return part and part.Position or nil
	end
	
	local function isInFOV(worldPosition, maxFov)
		local cam = Camera
		if not cam then return true end
		local dir = (worldPosition - cam.CFrame.Position).Unit
		local forward = cam.CFrame.LookVector.Unit
		local dot = math.clamp(dir:Dot(forward), -1, 1)
		local angle = math.deg(math.acos(dot))
		return angle <= (maxFov or 180)
	end
	-- Enhanced target selection with priority system
	local function getBestTarget()
		local bestTarget = nil
		local bestScore = -math.huge
		local playerHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not playerHRP then return nil end
		
		local fovLimit = (autoShootConfig and autoShootConfig.fovDegrees) or 180
		for _, target in pairs(Players:GetPlayers()) do
			if target ~= player and target.Team ~= player.Team and not isWhitelisted(target.Name) then
				local targetCharacter = target.Character
				local humanoid = targetCharacter and targetCharacter:FindFirstChildOfClass("Humanoid")
				local targetHRP = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")
				if humanoid and targetHRP and humanoid.Health > 0 then
					local distance = (targetHRP.Position - playerHRP.Position).Magnitude
					if distance <= ((autoShootConfig and autoShootConfig.maxRange) or 200) then
						local aimPos = getAimPartPosition(target, (autoShootConfig and autoShootConfig.aimPart) or "Head") or targetHRP.Position
						if isInFOV(aimPos, fovLimit) then
							local velocity = targetHRP.Velocity.Magnitude
							local distanceScore = 0
							local velocityScore = 0
							local healthScore = 0
							
							if autoShootConfig and autoShootConfig.priorityClosest then
								distanceScore = math.max(0, 100 - distance)
							end
							if autoShootConfig and autoShootConfig.prioritySlowMovement then
								velocityScore = math.max(0, 50 - velocity/2)
							end
							if autoShootConfig and autoShootConfig.priorityLowHealth then
								healthScore = math.max(0, 100 - humanoid.Health)
							end
							if not (autoShootConfig and (autoShootConfig.priorityClosest or autoShootConfig.prioritySlowMovement or autoShootConfig.priorityLowHealth)) then
								distanceScore = math.max(0, 100 - distance)
								velocityScore = math.max(0, 50 - velocity/2)
								healthScore = math.max(0, 100 - humanoid.Health)
							end
							
							local visibilityBonus = 0
							if autoShootConfig and autoShootConfig.preferVisibleTargets then
								if canHitAdvanced(target) then
									visibilityBonus = 50
								else
									visibilityBonus = -50
								end
							end
							
							local stickyBonus = 0
							if currentTarget == target and (tick() - lastTargetStamp) <= ((autoShootConfig and autoShootConfig.stickyTargetTime) or 1.0) then
								stickyBonus = 40
							end
							
							local totalScore = distanceScore + velocityScore + healthScore + visibilityBonus + stickyBonus
							if totalScore > bestScore then
								bestScore = totalScore
								bestTarget = target
							end
						end
					end
				end
			end
		end
		return bestTarget
	end
	-- Advanced movement prediction with multiple algorithms
	local function predictPositionAdvanced(targetPlayer)
		local targetCharacter = targetPlayer.Character
		if not targetCharacter then return nil end
		
		local humanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
		local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
		local head = targetCharacter:FindFirstChild("Head")
		
		if not humanoid or not targetHRP or not head then return nil end
		
		local aimPartName = (autoShootConfig and autoShootConfig.aimPart) or "Head"	
		local targetAimPos = getAimPartPosition(targetPlayer, aimPartName) or head.Position
		
		local playerCharacter = player.Character
		local playerHead = playerCharacter and playerCharacter:FindFirstChild("Head")
		local playerHRP = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")
		if not playerHead or not playerHRP then return nil end
		
		local origin = playerHead.Position
		local targetVel = targetHRP.Velocity
		local bulletSpeed = (autoShootConfig and autoShootConfig.bulletSpeed) or 450
		local gravity = (autoShootConfig and autoShootConfig.gravity) or workspace.Gravity or 196.2
		local useAdvanced = autoShootConfig and autoShootConfig.useAdvancedPrediction
		
		if not useAdvanced then
			local strength = autoShootConfig and autoShootConfig.predictionStrength or 0.5
			local pos = targetAimPos + (targetVel * strength)
			if autoShootConfig and autoShootConfig.smoothingFactor and aimSmoother.last then
				local a = math.clamp(autoShootConfig.smoothingFactor, 0, 1)
				pos = aimSmoother.last:Lerp(pos, a)
			end
			aimSmoother.last = pos
			return pos
		end
		
		-- Ballistic lead with gravity compensation (iterative)
		local gVec = Vector3.new(0, -gravity, 0)
		local toTarget = targetAimPos - origin
		local distance = toTarget.Magnitude
		local t = distance / math.max(1, bulletSpeed)
		
		for _ = 1, 3 do
			local drop = 0.5 * gVec * (t * t)
			local futurePos = targetAimPos + targetVel * t + drop
			local newToTarget = futurePos - origin
			t = newToTarget.Magnitude / math.max(1, bulletSpeed)
		end
		
		local predicted = targetAimPos + targetVel * t + 0.5 * gVec * (t * t)
		
		if autoShootConfig and autoShootConfig.leadMovingTargets == false then
			predicted = targetAimPos
		end
		
		if autoShootConfig and autoShootConfig.smoothingFactor and aimSmoother.last then
			local a = math.clamp(autoShootConfig.smoothingFactor, 0, 1)
			predicted = aimSmoother.last:Lerp(predicted, a)
		end
		aimSmoother.last = predicted
		return predicted
	end
	-- Enhanced hit detection with multiple checks
	local function canHitAdvanced(targetPlayer)
		local targetCharacter = targetPlayer.Character
		local playerCharacter = player.Character
		
		if not targetCharacter or not playerCharacter then return false end
		
		local targetHead = targetCharacter:FindFirstChild("Head")
		local playerHead = playerCharacter:FindFirstChild("Head")
		local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
		local playerHRP = playerCharacter:FindFirstChild("HumanoidRootPart")
		
		if not targetHead or not playerHead or not targetHRP or not playerHRP then return false end
		
		-- Check if multi-raycast is enabled
		if autoShootConfig and not autoShootConfig.useMultiRaycast then
			-- Single raycast check
			local direction = (targetHead.Position - playerHead.Position).unit
			local distance = (targetHead.Position - playerHead.Position).magnitude
			
			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = { playerCharacter }
			raycastParams.IgnoreWater = true
			
			local raycastResult = workspace:Raycast(playerHead.Position, direction * distance, raycastParams)
			
			return not raycastResult or raycastResult.Instance:IsDescendantOf(targetCharacter)
		end
		
		-- Multiple raycast checks for better accuracy
		local raycastPoints = {
			{start = playerHead.Position, end = targetHead.Position},
			{start = playerHead.Position, end = targetHRP.Position},
			{start = playerHRP.Position, end = targetHead.Position}
		}
		
		local hitCount = 0
		local totalChecks = #raycastPoints
		
		for _, raycast in ipairs(raycastPoints) do
			local direction = (raycast.end - raycast.start).unit
			local distance = (raycast.end - raycast.start).magnitude
			
			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = { playerCharacter }
			raycastParams.IgnoreWater = true
			
			local raycastResult = workspace:Raycast(raycast.start, direction * distance, raycastParams)
			
			if not raycastResult or raycastResult.Instance:IsDescendantOf(targetCharacter) then
				hitCount = hitCount + 1
			end
		end
		
		-- Return true if majority of checks pass
		return hitCount >= math.ceil(totalChecks * 0.6)
	end
	-- Target stability assessment with multiple factors
	local function isTargetStable(targetPlayer)
		local targetCharacter = targetPlayer.Character
		if not targetCharacter then return false end
		
		local humanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
		local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
		
		if not humanoid or not humanoidRootPart then return false end
		
		local velocity = humanoidRootPart.Velocity.magnitude
		local walkSpeed = humanoid.WalkSpeed
		local health = humanoid.Health
		local maxHealth = humanoid.MaxHealth
		
		-- Multiple stability factors
		local velocityStable = velocity < walkSpeed * 0.7
		local healthStable = health > maxHealth * 0.3
		local notJumping = humanoid:GetState() ~= Enum.HumanoidStateType.Jumping
		local notFalling = humanoid:GetState() ~= Enum.HumanoidStateType.Freefall
		
		-- Check if target is moving in a predictable pattern
		local lastPosition = targetPlayer:GetAttribute("LastPosition")
		local currentPosition = humanoidRootPart.Position
		local movementDistance = 0
		
		if lastPosition then
			movementDistance = (currentPosition - lastPosition).magnitude
		end
		
		targetPlayer:SetAttribute("LastPosition", currentPosition)
		
		local movementStable = movementDistance < 5 -- Not moving too fast
		
		return velocityStable and healthStable and notJumping and notFalling and movementStable
	end
	
	local function isValidAutoShootTarget(p)
		if not p or isWhitelisted(p.Name) then return false end
		if p == player or p.Team == player.Team then return false end
		local ch = p.Character
		if not ch then return false end
		local hum = ch:FindFirstChildOfClass("Humanoid")
		local hrp = ch:FindFirstChild("HumanoidRootPart")
		if not hum or not hrp or hum.Health <= 0 then return false end
		if ch:FindFirstChildOfClass("ForceField") then return false end
		local myHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not myHRP then return false end
		local dist = (hrp.Position - myHRP.Position).Magnitude
		if dist > ((autoShootConfig and autoShootConfig.maxRange) or 200) then return false end
		local aimPos = getAimPartPosition(p, (autoShootConfig and autoShootConfig.aimPart) or "Head") or hrp.Position
		if not isInFOV(aimPos, (autoShootConfig and autoShootConfig.fovDegrees) or 180) then return false end
		if autoShootConfig and autoShootConfig.preferVisibleTargets and not canHitAdvanced(p) then return false end
		return true
	end
	
	-- Enhanced Auto Shoot with advanced targeting
	local lastShotTime = 0
	local shotCooldown = 0.8 -- Minimum time between shots
	local consecutiveHits = 0
	local consecutiveMisses = 0
	
	local function on(bool)
		if bool then
			if hbConn then hbConn:Disconnect() end
			hbConn = RunService.Heartbeat:Connect(function()
				if not shooting then return end
				local now = tick()
				local baseCooldown = (autoShootConfig and autoShootConfig.shotCooldown) or shotCooldown
				local adaptiveCooldown = baseCooldown
				if autoShootConfig and autoShootConfig.adaptiveCooldown then
					if consecutiveHits > 3 then
						adaptiveCooldown = math.max(0.25, baseCooldown - 0.1)
					elseif consecutiveMisses > 2 then
						adaptiveCooldown = math.min(1.5, baseCooldown + 0.2)
					end
				end
				if now - lastShotTime < adaptiveCooldown then return end
				
				local stickyTime = (autoShootConfig and autoShootConfig.stickyTargetTime) or 1.0
				if currentTarget and (now - lastTargetStamp) <= stickyTime and isValidAutoShootTarget(currentTarget) then
					-- keep current target
				else
					currentTarget = getBestTarget()
					lastTargetStamp = now
				end
				
				if currentTarget and isValidAutoShootTarget(currentTarget) and isTargetStable(currentTarget) and canHitAdvanced(currentTarget) then
					local predictedPosition = predictPositionAdvanced(currentTarget)
					if predictedPosition then
						if player.Character:FindFirstChild("Sniper") then
							RemoteEvent:FireServer(predictedPosition, "Sniper")
							player.Character:FindFirstChild("Sniper"):Activate()
							lastShotTime = now
							local targetAimPos = getAimPartPosition(currentTarget, (autoShootConfig and autoShootConfig.aimPart) or "Head")
							if targetAimPos then
								local distanceError = (predictedPosition - targetAimPos).Magnitude
								if distanceError <= ((autoShootConfig and autoShootConfig.accuracyThreshold) or 5) then
									consecutiveHits = consecutiveHits + 1
									consecutiveMisses = 0
								else
									consecutiveMisses = consecutiveMisses + 1
									consecutiveHits = 0
								end
								if consecutiveHits > 10 then consecutiveHits = 5 end
								if consecutiveMisses > 10 then consecutiveMisses = 5 end
							end
						end
					end
				else
					-- No valid target, reduce cooldown for faster target acquisition
					shotCooldown = math.max(0.3, ((autoShootConfig and autoShootConfig.shotCooldown) or 0.8) - 0.05)
					autoShootConfig.shotCooldown = shotCooldown
					aimSmoother.last = nil
				end
			end)
		else
			shooting = false
			-- Reset accuracy tracking when stopping
			consecutiveHits = 0
			consecutiveMisses = 0
			if hbConn then hbConn:Disconnect() hbConn = nil end
			currentTarget = nil
			aimSmoother.last = nil
		end
	end
	
	-- Auto Shoot Configuration Variables
	local autoShootConfig = {
		enabled = false,
		shotCooldown = 0.8,
		maxRange = 200,
		accuracyThreshold = 5,
		adaptiveCooldown = true,
		priorityClosest = true,
		priorityLowHealth = true,
		prioritySlowMovement = true,
		useAdvancedPrediction = true,
		useMultiRaycast = true,
		smartTargetSwitching = true,
		leadMovingTargets = true,
		predictionStrength = 0.5,
		-- Ultimate additions
		fovDegrees = 85,
		bulletSpeed = 450,
		gravity = workspace.Gravity,
		aimPart = "Head",
		smoothingFactor = 0.5,
		stickyTargetTime = 1.0,
		preferVisibleTargets = true
	}
	
	undTab:CreateToggle({
		Name = "ðŸŽ¯ Auto Shoot (Enhanced)",
		CurrentValue = false,
		Callback = function(bool)
			autoShootConfig.enabled = bool
			shooting = bool
			if bool then 
				on(true)
				notifySuccess("Auto Shoot Enhanced", "Advanced sniper targeting activated with AI prediction", 4)
			else 
				on(false) 
				notify("Auto Shoot Stopped", "Advanced sniper targeting deactivated", 3)
			end
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸŽ¯ Shot Cooldown",
		Range = {0.1, 2.0},
		Increment = 0.1,
		Suffix = "s",
		CurrentValue = 0.8,
		Callback = function(value)
			autoShootConfig.shotCooldown = value
			shotCooldown = value
			notifySuccess("Cooldown Updated", "Shot cooldown set to " .. string.format("%.1f", value) .. "s", 3)
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸ“ Max Range",
		Range = {50, 500},
		Increment = 10,
		Suffix = " studs",
		CurrentValue = 200,
		Callback = function(value)
			autoShootConfig.maxRange = value
			notifySuccess("Range Updated", "Maximum targeting range set to " .. value .. " studs", 3)
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸ‘ï¸ FOV Limit",
		Range = {20, 180},
		Increment = 5,
		Suffix = "Â°",
		CurrentValue = 85,
		Callback = function(value)
			autoShootConfig.fovDegrees = value
			notifySuccess("FOV Updated", "FOV limit set to " .. value .. "Â°", 3)
		end
	})
	
	undTab:CreateToggle({
		Name = "ðŸ§  Adaptive Cooldown",
		CurrentValue = true,
		Callback = function(bool)
			autoShootConfig.adaptiveCooldown = bool
			if bool then
				notifySuccess("Adaptive Cooldown", "Shot timing will adjust based on accuracy", 3)
			else
				notify("Fixed Cooldown", "Using fixed shot timing", 3)
			end
		end
	})
	
	undTab:CreateToggle({
		Name = "ðŸŽ¯ Advanced Prediction",
		CurrentValue = true,
		Callback = function(bool)
			autoShootConfig.useAdvancedPrediction = bool
			if bool then
				notifySuccess("Advanced Prediction", "Using multi-algorithm position prediction", 3)
			else
				notify("Basic Prediction", "Using simple linear prediction", 3)
			end
		end
	})
	
	undTab:CreateToggle({
		Name = "ðŸ” Multi-Raycast",
		CurrentValue = true,
		Callback = function(bool)
			autoShootConfig.useMultiRaycast = bool
			if bool then
				notifySuccess("Multi-Raycast", "Enhanced hit detection with multiple checks", 3)
			else
				notify("Single-Raycast", "Basic hit detection", 3)
			end
		end
	})
	
	undTab:CreateDropdown({
		Name = "ðŸŽ¯ Target Priority",
		Options = {"Closest", "Lowest Health", "Slowest Movement", "Balanced"},
		CurrentOption = "Balanced",
		MultipleOptions = false,
		Callback = function(option)
			if option == "Closest" then
				autoShootConfig.priorityClosest = true
				autoShootConfig.priorityLowHealth = false
				autoShootConfig.prioritySlowMovement = false
			elseif option == "Lowest Health" then
				autoShootConfig.priorityClosest = false
				autoShootConfig.priorityLowHealth = true
				autoShootConfig.prioritySlowMovement = false
			elseif option == "Slowest Movement" then
				autoShootConfig.priorityClosest = false
				autoShootConfig.priorityLowHealth = false
				autoShootConfig.prioritySlowMovement = true
			elseif option == "Balanced" then
				autoShootConfig.priorityClosest = true
				autoShootConfig.priorityLowHealth = true
				autoShootConfig.prioritySlowMovement = true
			end
			notifySuccess("Priority Updated", "Target priority set to: " .. option, 3)
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸš€ Bullet Speed",
		Range = {200, 1200},
		Increment = 25,
		Suffix = " stud/s",
		CurrentValue = 450,
		Callback = function(value)
			autoShootConfig.bulletSpeed = value
			notifySuccess("Bullet Speed", "Bullet speed set to " .. value, 3)
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸŒ Gravity Compensation",
		Range = {0, 300},
		Increment = 5,
		Suffix = " stud/sÂ²",
		CurrentValue = math.floor(workspace.Gravity + 0.5),
		Callback = function(value)
			autoShootConfig.gravity = value
			notifySuccess("Gravity Updated", "Using gravity " .. value, 3)
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸŽ¯ Aim Smoothing",
		Range = {0, 1},
		Increment = 0.05,
		Suffix = "",
		CurrentValue = 0.5,
		Callback = function(value)
			autoShootConfig.smoothingFactor = value
			notifySuccess("Smoothing", "Aim smoothing set to " .. string.format("%.2f", value), 3)
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸ§² Sticky Target Time",
		Range = {0, 3},
		Increment = 0.1,
		Suffix = "s",
		CurrentValue = 1.0,
		Callback = function(value)
			autoShootConfig.stickyTargetTime = value
			notifySuccess("Sticky Target", "Sticky time set to " .. string.format("%.1f", value) .. "s", 3)
		end
	})
	
	undTab:CreateDropdown({
		Name = "ðŸŽ¯ Aim Part",
		Options = {"Head", "HumanoidRootPart", "UpperTorso"},
		CurrentOption = "Head",
		MultipleOptions = false,
		Callback = function(option)
			autoShootConfig.aimPart = option
			notifySuccess("Aim Part", "Now aiming at " .. option, 3)
		end
	})
	
	undTab:CreateToggle({
		Name = "ðŸ”Ž Prefer Visible Targets",
		CurrentValue = true,
		Callback = function(bool)
			autoShootConfig.preferVisibleTargets = bool
			if bool then
				notifySuccess("Visibility Bias", "Will favor targets with clear line of sight", 3)
			else
				notify("Visibility Bias", "Disabled", 3)
			end
		end
	})
	
	undTab:CreateToggle({
		Name = "ðŸŽ¯ Smart Target Switching",
		CurrentValue = true,
		Callback = function(bool)
			autoShootConfig.smartTargetSwitching = bool
			if bool then
				notifySuccess("Smart Switching", "Will switch targets if current target becomes invalid", 3)
			else
				notify("Fixed Target", "Will stick to current target until it's eliminated", 3)
			end
		end
	})
	
	undTab:CreateToggle({
		Name = "ðŸŽ¯ Lead Moving Targets",
		CurrentValue = true,
		Callback = function(bool)
			autoShootConfig.leadMovingTargets = bool
			if bool then
				notifySuccess("Lead Shots", "Will predict and lead moving targets", 3)
			else
				notify("Direct Shots", "Will shoot directly at current position", 3)
			end
		end
	})
	
	undTab:CreateSlider({
		Name = "ðŸŽ¯ Prediction Strength",
		Range = {0.1, 1.0},
		Increment = 0.1,
		Suffix = "",
		CurrentValue = 0.5,
		Callback = function(value)
			autoShootConfig.predictionStrength = value
			notifySuccess("Prediction Updated", "Prediction strength set to " .. string.format("%.1f", value), 3)
		end
	})
	
	undTab:CreateButton({
		Name = "ðŸ“Š Show Accuracy Stats",
		Callback = function()
			local accuracy = consecutiveHits > 0 and (consecutiveHits / (consecutiveHits + consecutiveMisses)) * 100 or 0
			notifyWithActions(
				"ðŸŽ¯ Accuracy Statistics",
				string.format("Hits: %d | Misses: %d | Accuracy: %.1f%%", consecutiveHits, consecutiveMisses, accuracy),
				{
					["Reset Stats"] = function()
						consecutiveHits = 0
						consecutiveMisses = 0
						notifySuccess("Stats Reset", "Accuracy statistics have been reset", 3)
					end,
					["Close"] = function()
						-- Just close
					end
				},
				10
			)
		end
	})


	undTab:CreateButton({
		Name = "ðŸŽ¯ Quick Target Test",
		Callback = function()
			local bestTarget = getBestTarget()
			if bestTarget then
				notifyWithActions(
					"ðŸŽ¯ Target Found",
					string.format("Best target: %s\nDistance: %.1f studs\nHealth: %.0f%%", 
						bestTarget.DisplayName,
						(bestTarget.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude,
						bestTarget.Character.Humanoid.Health
					),
					{
						["Shoot Now"] = function()
							if autoShootConfig.enabled then
								local predictedPosition = predictPositionAdvanced(bestTarget)
								if predictedPosition then
									local args = { [1] = predictedPosition, [2] = "Sniper" }
									if player.Character:FindFirstChild("Sniper") then
										RemoteEvent:FireServer(unpack(args))
										player.Character:FindFirstChild("Sniper"):Activate()
										notifySuccess("Test Shot", "Fired test shot at " .. bestTarget.DisplayName, 3)
									end
								end
							else
								notifyWarning("Auto Shoot Disabled", "Please enable Auto Shoot first", 4)
							end
						end,
						["Close"] = function()
							-- Just close
						end
					},
					15
				)
			else
				notifyWarning("No Targets", "No valid targets found within range", 4)
			end
		end
	})

  -- ESP Variables
  local ESPEnabled = false
  local ESPConnections = {}
  
  -- Function to add Highlight to a character
  local function addHighlight(character)
      if not ESPEnabled then return end
      if character:FindFirstChild("ESPHighlight") then return end
  
      local player = Players:GetPlayerFromCharacter(character)
      if not player then return end
  
      local highlight = Instance.new("Highlight")
      highlight.Name = "ESPHighlight"
      highlight.FillColor = player.TeamColor.Color  -- color by team
      highlight.OutlineColor = Color3.new(0, 0, 0)
      highlight.FillTransparency = 0.5
      highlight.Parent = character
  end
  
  -- Enable ESP
  local function StartESP()
      ESPEnabled = true
      -- Apply to current players
      for _, player in ipairs(Players:GetPlayers()) do
          if player ~= LocalPlayer and player.Character then
              addHighlight(player.Character)
          end
          local conn = player.CharacterAdded:Connect(function(char)
              task.wait(0.5)
              addHighlight(char)
          end)
          table.insert(ESPConnections, conn)
      end
  
      -- For new players
      table.insert(ESPConnections, Players.PlayerAdded:Connect(function(player)
          local conn = player.CharacterAdded:Connect(function(char)
              task.wait(0.5)
              addHighlight(char)
          end)
          table.insert(ESPConnections, conn)
      end))
  end
  
  -- Disable ESP
  local function StopESP()
      ESPEnabled = false
      for _, conn in pairs(ESPConnections) do
          conn:Disconnect()
      end
      ESPConnections = {}
      -- Remove all highlights
      for _, plr in ipairs(Players:GetPlayers()) do
          if plr.Character and plr.Character:FindFirstChild("ESPHighlight") then
              plr.Character.ESPHighlight:Destroy()
          end
      end
  end
  
  -- Add into ðŸŽ¯ Underground War tab
  undTab:CreateToggle({
      Name = "ðŸ‘€ ESP Highlight (Team Color)",
      CurrentValue = false,
      Callback = function(state)
          if state then
              StartESP()
              notifySuccess("ESP Enabled", "Players are now highlighted by team color", 4)
          else
              StopESP()
              notify("ESP Disabled", "All highlights removed", 3)
          end
      end
  })
  
  undTab:CreateInput({
      Name = "ðŸŽ¯ ESP Target Filter",
      PlaceholderText = "Enter name (leave empty for all)",
      RemoveTextAfterFocusLost = false,
      Callback = function(text)
          ESPKeyword = text or ""
          if ESPEnabled then
              StartESP()
              notify("ESP Updated", "Now filtering ESP with: " .. (ESPKeyword ~= "" and ESPKeyword or "ALL"), 4)
          end
      end
  })
  
  -- fallback cho cloneref náº¿u env khÃ´ng cÃ³
  local cloneref = cloneref or function(x) return x end
  
  -- ====== Auto Sword (keep original logic) ======
  -- cleanup instance cÅ©
  local connections = getgenv().configs and getgenv().configs.connections
  if connections then
      local Disable = getgenv().configs.Disable
      for i, v in pairs(connections) do
          v:Disconnect()
      end
      if Disable then
          Disable:Fire()
          Disable:Destroy()
      end
      table.clear(getgenv().configs)
  end
  
  local Disable = Instance.new("BindableEvent")
  getgenv().configs = {
      connections = {},
      Disable = Disable,
      Size = Vector3.new(8, 5.5, 8), -- default box expansion
      DeathCheck = true
  }
  
  local Players = cloneref(game:GetService("Players"))
  local RunService = cloneref(game:GetService("RunService"))
  local lp = Players.LocalPlayer
  local Run = true
  local Ignorelist = OverlapParams.new()
  Ignorelist.FilterType = Enum.RaycastFilterType.Include
  
  local function getchar(p)
      local p = p or lp
      return p.Character
  end
  
  local function gethumanoid(p)
      local char
      if typeof(p) == "Instance" and p:IsA("Model") then
          -- Náº¿u p lÃ  Character Model
          char = p
      elseif typeof(p) == "Instance" and p:IsA("Player") then
          -- Náº¿u p lÃ  Player
          char = p.Character
      elseif p == nil then
          -- Náº¿u bá» trá»‘ng -> láº¥y localplayer
          char = lp.Character
      end
  
      if char then
          return char:FindFirstChildWhichIsA("Humanoid")
      end
  end
  
  local function IsAlive(h)
      return h and h.Health > 0
  end
  
  local function GetTouchInterest(Tool)
      return Tool and Tool:FindFirstChildWhichIsA("TouchTransmitter", true)
  end
  
  local function GetCharacters(LocalPlayerChar)
      local Characters = {}
      for i, v in ipairs(Players:GetPlayers()) do
          table.insert(Characters, getchar(v))
      end
      -- giá»¯ nguyÃªn logic gá»‘c
      table.remove(Characters, table.find(Characters, LocalPlayerChar))
      return Characters
  end
  
  local function Attack(Tool, TouchPart, ToTouch)
      if Tool:IsDescendantOf(workspace) then
          Tool:Activate()
          firetouchinterest(TouchPart, ToTouch, 1)
          firetouchinterest(TouchPart, ToTouch, 0)
      end
  end
  
  table.insert(getgenv().configs.connections, Disable.Event:Connect(function()
      Run = false
  end))
  
  -- loop chÃ­nh (nguyÃªn gá»‘c)
  task.spawn(function()
      while Run do
          local char = getchar()
          if IsAlive(gethumanoid(char)) then
              local Tool = char and char:FindFirstChildWhichIsA("Tool")
              local TouchInterest = Tool and GetTouchInterest(Tool)
              if TouchInterest then
                  local TouchPart = TouchInterest.Parent
                  local Characters = GetCharacters(char)
                  Ignorelist.FilterDescendantsInstances = Characters
                  local InstancesInBox = workspace:GetPartBoundsInBox(
                      TouchPart.CFrame,
                      TouchPart.Size + getgenv().configs.Size,
                      Ignorelist
                  )
                  for i, v in ipairs(InstancesInBox) do
                      local Character = v:FindFirstAncestorWhichIsA("Model")
                      if table.find(Characters, Character) then
                          if getgenv().configs.DeathCheck then
                              if IsAlive(gethumanoid(Character)) then
                                  Attack(Tool, TouchPart, v)
                              end
                          else
                              Attack(Tool, TouchPart, v)
                          end
                      end
                  end
              end
          end
          RunService.Heartbeat:Wait()
      end
  end)
  
    -- Start / Stop Auto Sword
  local function StartAutoSword()
      if AutoSwordEnabled then return end
      AutoSwordEnabled = true
      Run = true
      notifySuccess("Auto Sword Enabled", "Now auto-attacking with sword", 4)
  
      -- khá»Ÿi Ä‘á»™ng loop
      task.spawn(function()
          while Run do
              local char = getchar()
              if IsAlive(gethumanoid(char)) then
                  local Tool = char and char:FindFirstChildWhichIsA("Tool")
                  local TouchInterest = Tool and GetTouchInterest(Tool)
                  if TouchInterest then
                      local TouchPart = TouchInterest.Parent
                      local Characters = GetCharacters(char)
                      Ignorelist.FilterDescendantsInstances = Characters
                      local InstancesInBox = workspace:GetPartBoundsInBox(
                          TouchPart.CFrame,
                          TouchPart.Size + getgenv().configs.Size,
                          Ignorelist
                      )
                      for i, v in ipairs(InstancesInBox) do
                          local Character = v:FindFirstAncestorWhichIsA("Model")
                          if table.find(Characters, Character) then
                              if getgenv().configs.DeathCheck then
                                  if IsAlive(gethumanoid(Character)) then
                                      Attack(Tool, TouchPart, v)
                                  end
                              else
                                  Attack(Tool, TouchPart, v)
                              end
                          end
                      end
                  end
              end
              RunService.Heartbeat:Wait()
          end
      end)
  end
  
  local function StopAutoSword()
      if not AutoSwordEnabled then return end
      AutoSwordEnabled = false
      Run = false
      if getgenv().configs.Disable then
          getgenv().configs.Disable:Fire()
      end
      notify("Auto Sword Disabled", "Stopped auto sword attack", 3)
  end
  
  -- Toggle button in Underground War tab
  undTab:CreateToggle({
      Name = "âš”ï¸ Auto Sword",
      CurrentValue = false,
      Callback = function(state)
          if state then
              StartAutoSword()
          else
              StopAutoSword()
          end
      end
  })
  
  local function fmt1(n) -- luÃ´n hiá»ƒn thá»‹ 1 chá»¯ sá»‘ tháº­p phÃ¢n
      return string.format("%.1f", tonumber(n) or 0)
  end
  
  undTab:CreateInput({
      Name = "ðŸ“ Auto Sword Range",
      PlaceholderText = "5  |  5,4  |  3.2,5,7",
      RemoveTextAfterFocusLost = false,
      Callback = function(text)
          if text == "" then return end
  
          -- tÃ¡ch theo dáº¥u pháº©y hoáº·c khoáº£ng tráº¯ng
          local parts, nums = {}, {}
          for token in string.gmatch(text, "[^,%s]+") do
              table.insert(parts, token)
          end
          for _, s in ipairs(parts) do
              local n = tonumber(s)
              if n then table.insert(nums, n) end
          end
  
          local newSize
          if #nums == 1 then
              newSize = Vector3.new(nums[1], nums[1], nums[1])
          elseif #nums == 2 then
              newSize = Vector3.new(nums[1], nums[2], nums[1])
          elseif #nums >= 3 then
              newSize = Vector3.new(nums[1], nums[2], nums[3])
          else
              notifyError("Invalid Input", "Enter 1, 2, or 3 numbers (e.g. 5  |  5,4  |  3.2,5,7)", 5)
              return
          end
  
          getgenv().configs.Size = newSize
          notifySuccess(
              "Auto Sword Range Updated",
              string.format("New size: %s, %s, %s", fmt1(newSize.X), fmt1(newSize.Y), fmt1(newSize.Z)),
              4
          )
      end
  })
	
	undTab:CreateButton({
		Name = "ðŸ”« Sniper/Sword Combination",
		Callback = function()
			if plr.Character:FindFirstChild"Sword" or plr.Character:FindFirstChild"Sniper" then
				plr.Character.Humanoid:UnequipTools()
				notifyWarning("Equipment Warning", "Please don't equip Sniper/Sword manually when using this feature", 6)
			else
				if not (shooting and auraL) then
					notifyWithActions(
						"Combo Setup",
						"For optimal performance, enable Real Aura and Auto Shoot first.",
						{
							["Enable Both"] = function()
								-- This would require triggering the toggles programmatically
								notifySuccess("Recommendation", "Please enable Real Aura and Auto Shoot toggles manually", 5)
							end,
							["Continue Anyway"] = function()
								if plr.Backpack:FindFirstChild("Sniper") and plr.Backpack:FindFirstChild("Sword") then
									plr.Backpack.Sniper.Parent = plr.Character
									plr.Backpack.Sword.Parent = plr.Character
									notifySuccess("Weapons Equipped", "Sniper and Sword combo ready!", 4)
								else
									notifyError("Missing Weapons", "Sniper or Sword not found in backpack", 5)
								end
							end
						},
						12
					)
					return false
				end
				if plr.Backpack:FindFirstChild("Sniper") and plr.Backpack:FindFirstChild("Sword") then
					plr.Backpack.Sniper.Parent = plr.Character
					plr.Backpack.Sword.Parent = plr.Character
					notifySuccess("Ultimate Combo", "Sniper + Sword combination activated!", 4)
				else
					notifyError("Missing Equipment", "Could not find required weapons in backpack", 5)
				end
			end
		end
	})

	undTab:CreateInput({
		Name = "ðŸ›¡ï¸ Add to Whitelist",
		PlaceholderText = "players/me/random/enemies/all/others/team or name",
		RemoveTextAfterFocusLost = false,
		Callback = function(text)
			if text ~= "" then
				local p = G:getPlayers(text)
				if p and #p > 0 then
					for i, v in pairs(p) do 
						addToWhitelist(v.Name) 
					end
					notifySuccess("Whitelist Updated", "Added " .. #p .. " player(s) to whitelist", 4)
				else
					notifyError("Player Not Found", "Could not find player(s) matching: " .. text, 5)
				end
			end
		end
	})

	undTab:CreateInput({
		Name = "âŒ Remove from Whitelist",
		PlaceholderText = "players/me/random/enemies/all/others/team or name",
		RemoveTextAfterFocusLost = false,
		Callback = function(text)
			if text ~= "" then
				local p = G:getPlayers(text)
				if p and #p > 0 then
					for i, v in pairs(p) do 
						removeFromWhitelist(v.Name) 
					end
					notify("Whitelist Updated", "Removed " .. #p .. " player(s) from whitelist", 4)
				else
					notifyError("Player Not Found", "Could not find player(s) matching: " .. text, 5)
				end
			end
		end
	})

	undTab:CreateInput({
		Name = "ðŸ” Check Whitelist Status",
		PlaceholderText = "players/me/random/enemies/all/others/team or name",
		RemoveTextAfterFocusLost = false,
		Callback = function(text)
			if text ~= "" then
				local p = G:getPlayers(text)
				if p and #p > 0 then
					for i, v in pairs(p) do
						if isWhitelisted(v.Name) then
							notifySuccess("âœ… " .. v.DisplayName, "This player is protected (whitelisted)", 4)
						else
							notify("âŒ " .. v.DisplayName, "This player is not whitelisted", 4)
						end
					end
				else
					notifyError("Player Not Found", "Could not find player(s) matching: " .. text, 5)
				end
			end
		end
	})
else
	local w3 = Window:CreateTab("ðŸ›¡ï¸ Whitelist Manager", "shield")
	
	w3:CreateInput({
		Name = "âž• Add to Whitelist",
		PlaceholderText = "players/me/random/enemies/all/others/team or name",
		RemoveTextAfterFocusLost = false,
		Callback = function(text)
			if text ~= "" then
				local p = G:getPlayers(text)
				if p and #p > 0 then
					for i, v in pairs(p) do 
						addToWhitelist(v.Name) 
					end
					notifySuccess("Whitelist Updated", "Successfully added " .. #p .. " player(s) to protection list", 4)
				else
					notifyError("Player Not Found", "No players found matching: " .. text, 5)
				end
			end
		})
	
	w3:CreateInput({
		Name = "âž– Remove from Whitelist",
		PlaceholderText = "players/me/random/enemies/all/others/team or name",
		RemoveTextAfterFocusLost = false,
		Callback = function(text)
			if text ~= "" then
				local p = G:getPlayers(text)
				if p and #p > 0 then
					for i, v in pairs(p) do 
						removeFromWhitelist(v.Name) 
					end
					notify("Whitelist Updated", "Removed " .. #p .. " player(s) from protection list", 4)
				else
					notifyError("Player Not Found", "No players found matching: " .. text, 5)
				end
			end
		})
	
	w3:CreateInput({
		Name = "ðŸ” Check Protection Status",
		PlaceholderText = "players/me/random/enemies/all/others/team or name",
		RemoveTextAfterFocusLost = false,
		Callback = function(text)
			if text ~= "" then
				local p = G:getPlayers(text)
				if p and #p > 0 then
					for i, v in pairs(p) do
						if isWhitelisted(v.Name) then
							notifySuccess("ðŸ›¡ï¸ " .. v.DisplayName, "This player is protected from targeting", 4)
						else
							notify("âš”ï¸ " .. v.DisplayName, "This player can be targeted", 4)
						end
					end
				else
					notifyError("Search Failed", "No players found matching your search", 5)
				end
			end
		end
	})

	-- Game recommendation for other games
	local otherGamePlaceId = (9791603388)
	local function getGameDetails(placeId)
		local success, gameInfo = pcall(function()
			return MarketplaceService:GetProductInfo(placeId)
		end)
		if success then
			return gameInfo.Name
		else
			warn("Failed to get game details: " .. tostring(gameInfo))
			return "Underground War"
		end
	end
	
	local otherGameName = getGameDetails(otherGamePlaceId)
	notifyWithActions(
		"ðŸŽ® Enhanced Features Available",
		"Join '" .. otherGameName .. "' for advanced combat features including auto-sniper and weapon combinations!",
		{
			["ðŸš€ Teleport Now"] = function()
				notify("Teleporting", "Joining " .. otherGameName .. "...", 3)
				TeleportService:Teleport(otherGamePlaceId, Players.LocalPlayer)
			end,
			["ðŸ“‹ Copy Game ID"] = function()
				GC(tostring(otherGamePlaceId))
			end,
			["Maybe Later"] = function()
				notify("Understood", "You can always teleport later for enhanced features", 4)
			end
		},
		20
	)
end

spawn(autoU)

-- Enhanced player leaving notification
Players.PlayerRemoving:Connect(function(v)
	if isWhitelisted(v.Name) then
		removeFromWhitelist(v.Name)
		notify("ðŸ‘‹ Player Left", v.DisplayName .. " was automatically removed from whitelist", 5)
	end
end)

-- Enhanced script completion notification
notifySuccess("ðŸš€ Script Ready", "All systems loaded successfully! Enhanced Auto Shoot with AI prediction is now available!", 6)

return _G.name